import React, { createContext, useContext, useMemo, useState, useCallback, useEffect } from 'react'

const dict = {
  zh: {
    app_title: 'LiquorChain dApp',
    network_tag: 'Aptos Testnet',
    disconnected: '未连接',
    address_label: '地址',
    disconnect: '断开',
    connect_petra: '连接 Petra',
    hero_title: '信任每一滴佳酿',
    hero_subtitle: '基于 Aptos 区块链的奢侈品酒类溯源平台',
    nav_home: '首页',
    nav_dashboard: '仪表盘',
    nav_verify: '验证',
    nav_profile: '个人',
    cta_verify: '立即验证',
    cta_dashboard: '进入仪表盘',
    section_collection_account: '集合与账户',
    create_collection: '创建集合',
    init_tokenstore: '初始化 TokenStore',
    section_mint: 'NFT 铸造',
    type: '类型',
    batch_nft: '批次 NFT',
    bottle_nft: '瓶子 NFT',
    linked_batch_id: '关联批次 ID',
    linked_batch_id_placeholder: '例如 1',
    name: '名称',
    name_placeholder: '例如：Liquor Batch #1',
    description: '描述',
    description_placeholder: '描述信息',
    uri: 'Token URI',
    uri_placeholder: 'https://...',
    mint_nft: '铸造 NFT',
    feature_anti_counterfeit: '防伪验证',
    feature_transparency: '供应链透明',
    feature_investment: '投资价值',
    module_address_label: '模块地址',
    footer: '在 Aptos Testnet 上',
    need_connect: '请先连接 Petra 钱包',
    create_collection_success: '集合创建成功，Tx:',
    create_collection_fail: '集合创建失败',
    init_store_success: 'TokenStore 初始化成功，Tx:',
    init_store_fail: 'TokenStore 初始化失败',
    need_init_store: '请先在仪表盘点击“初始化 TokenStore”',
    mint_success: '铸造成功，Tx:',
    mint_fail: '铸造失败',
    require_batch_id: '请输入批次 ID',
    require_name: '请输入名称',
    require_description: '请输入描述',
    require_uri: '请输入 Token URI',
    language: '语言',
    zh: '中文',
    en: '英文',
    selected_brands: '精选品牌',
    bottle_registry: '酒瓶注册',
    regulatory_attestations: '合规凭证',
    role_based_access: '角色与权限',
    status_active: '在售',
    status_sealed: '已封',
    status_unsealed: '未封',
    batch_id: '批次',
    harvested: '采收日期',
    sugar: '糖度',
    weight: '重量',
    ripeness: '成熟度',
    farmer: '农户地址',
    winemaker: '酿酒师地址',
    nfc: 'NFC',
    attestation_id: '凭证',
    compliance_standard: '合规标准',
    attestation_date: '签发日期',
    regulator_address: '监管地址',
    valid: '有效',
    capabilities: '权限',
    role_farmer: '农户',
    role_winemaker: '酿酒师',
    role_distributor: '分销商',
    role_regulator: '监管机构',
    role_retailer: '零售商',
    role_consortium: '联盟',
    view_detail: '查看详情',
    details: '详情',
    current_owner: '当前所有者',
    nft_metadata: 'NFT 元数据',
    transaction_history: '交易历史',
    authenticity_status: '真伪状态',
    provenance_map: '溯源地图',
    bottle_id: '酒瓶编号',
    title: '标题',
    status: '状态',
    module: '模块',
    section_roles: '角色管理',
    set_roles: '设置角色',
    roles_input_placeholder: '例如：Farmer,Winemaker,Distributor',
    set_roles_success: '角色设置成功，Tx:',
    set_roles_fail: '角色设置失败',
    use_ipfs: '使用 IPFS 存储元数据',
    ipfs_provider: 'IPFS 提供商',
    provider_pinata: 'Pinata',
    provider_web3: 'Web3.Storage',
    ipfs_token: 'API Token',
    ipfs_required: '请填写 IPFS 提供商与 Token',
    qr_generated: '二维码已生成',
    mint_qr_nft: '铸造二维码 NFT',
    mint_qr_success: '二维码 NFT 铸造成功，Tx:',
    mint_qr_fail: '二维码 NFT 铸造失败',
    cid: 'CID',
    qr_cid: 'QR CID',
    verify_title: '扫码/链接验证',
    verify_help_title: '新手指引',
    verify_help_text: '1) 扫描二维码或输入 ipfs://CID/链接；2) 自动解析 CID 并从 IPFS 获取元数据；3) 交叉检查 Indexer 中由模块地址铸造的 Token 活动；4) 展示验证结果与详细信息。',
    verify_input_cid: 'CID 或链接',
    verify_start: '开始验证',
    verify_fetching: '正在解析与检索...',
    verify_ok: '验证成功',
    verify_fail: '验证失败',
    metadata: '元数据',
    attributes: '属性',
    verify_result: '验证结果',
    indexer_label: '索引器事件',
    event_filter: '事件过滤',
    filter_all: '全部',
    filter_mint: '仅 Mint',
    filter_transfer: '仅 Transfer',
    proof_card: '证明卡片',
  },
  en: {
    app_title: 'LiquorChain dApp',
    network_tag: 'Aptos Testnet',
    disconnected: 'Disconnected',
    address_label: 'Address',
    disconnect: 'Disconnect',
    connect_petra: 'Connect Petra',
    hero_title: 'Trust Every Drop',
    hero_subtitle: 'Luxury spirits provenance on the Aptos blockchain',
    nav_home: 'Home',
    nav_dashboard: 'Dashboard',
    nav_verify: 'Verify',
    nav_profile: 'Profile',
    cta_verify: 'Verify Now',
    cta_dashboard: 'Go to Dashboard',
    section_collection_account: 'Collection & Account',
    create_collection: 'Create Collection',
    init_tokenstore: 'Init TokenStore',
    section_mint: 'Mint NFT',
    type: 'Type',
    batch_nft: 'Batch NFT',
    bottle_nft: 'Bottle NFT',
    linked_batch_id: 'Linked Batch ID',
    linked_batch_id_placeholder: 'e.g. 1',
    name: 'Name',
    name_placeholder: 'e.g., Liquor Batch #1',
    description: 'Description',
    description_placeholder: 'Description',
    uri: 'Token URI',
    uri_placeholder: 'https://...',
    mint_nft: 'Mint NFT',
    feature_anti_counterfeit: 'Anti-counterfeit',
    feature_transparency: 'Supply chain transparency',
    feature_investment: 'Investment value',
    module_address_label: 'Module Address',
    footer: 'on Aptos Testnet',
    need_connect: 'Please connect Petra wallet first',
    create_collection_success: 'Collection created, Tx:',
    create_collection_fail: 'Collection creation failed',
    init_store_success: 'TokenStore initialized, Tx:',
    init_store_fail: 'TokenStore initialization failed',
    need_init_store: 'Please run "Init TokenStore" in Dashboard first',
    mint_success: 'Mint success, Tx:',
    mint_fail: 'Mint failed',
    require_batch_id: 'Please input batch ID',
    require_name: 'Please input name',
    require_description: 'Please input description',
    require_uri: 'Please input Token URI',
    language: 'Language',
    zh: 'Chinese',
    en: 'English',
    selected_brands: 'Selected Brands',
    bottle_registry: 'Bottle Registry',
    regulatory_attestations: 'Regulatory Attestations',
    role_based_access: 'Role-Based Access',
    status_active: 'Active',
    status_sealed: 'Sealed',
    status_unsealed: 'Unsealed',
    batch_id: 'Batch',
    harvested: 'Harvested',
    sugar: 'Sugar',
    weight: 'Weight',
    ripeness: 'Ripeness',
    farmer: 'Farmer',
    winemaker: 'Winemaker',
    nfc: 'NFC',
    attestation_id: 'Attestation',
    compliance_standard: 'Compliance Standard',
    attestation_date: 'Attestation Date',
    regulator_address: 'Regulator Address',
    valid: 'Valid',
    capabilities: 'Capabilities',
    role_farmer: 'Farmer',
    role_winemaker: 'Winemaker',
    role_distributor: 'Distributor',
    role_regulator: 'Regulator',
    role_retailer: 'Retailer',
    role_consortium: 'Consortium',
    view_detail: 'View Details',
    details: 'Details',
    current_owner: 'Current Owner',
    nft_metadata: 'NFT Metadata',
    transaction_history: 'Transaction History',
    authenticity_status: 'Authenticity Status',
    provenance_map: 'Provenance Map',
    bottle_id: 'Bottle ID',
    title: 'Title',
    status: 'Status',
    module: 'Module',
    section_roles: 'Role Management',
    set_roles: 'Set Roles',
    roles_input_placeholder: 'e.g., Farmer,Winemaker,Distributor',
    set_roles_success: 'Roles set, Tx:',
    set_roles_fail: 'Roles set failed',
    use_ipfs: 'Store metadata on IPFS',
    ipfs_provider: 'IPFS Provider',
    provider_pinata: 'Pinata',
    provider_web3: 'Web3.Storage',
    ipfs_token: 'API Token',
    ipfs_required: 'Please provide IPFS provider and token',
    qr_generated: 'QR Code generated',
    mint_qr_nft: 'Mint QR NFT',
    mint_qr_success: 'QR NFT minted, Tx:',
    mint_qr_fail: 'QR NFT mint failed',
    cid: 'CID',
    qr_cid: 'QR CID',
    verify_title: 'QR / Link Verification',
    verify_help_title: 'Getting Started',
    verify_help_text: '1) Scan the QR or input ipfs://CID/link; 2) We parse CID and fetch metadata from IPFS; 3) Cross-check Indexer for token activities by module address; 4) Show verification result and details.',
    verify_input_cid: 'CID or Link',
    verify_start: 'Start Verify',
    verify_fetching: 'Parsing and fetching...',
    verify_ok: 'Verified',
    verify_fail: 'Verification Failed',
    metadata: 'Metadata',
    attributes: 'Attributes',
    verify_result: 'Verification Result',
    indexer_label: 'Indexer Events',
    event_filter: 'Event Filter',
    filter_all: 'All',
    filter_mint: 'Mint Only',
    filter_transfer: 'Transfer Only',
    proof_card: 'Proof Card',
  }
}

const LanguageContext = createContext(null)

export function LanguageProvider({ children }) {
  const initial = useMemo(() => {
    const saved = typeof window !== 'undefined' ? window.localStorage.getItem('lang') : null
    if (saved === 'zh' || saved === 'en') return saved
    const nav = typeof navigator !== 'undefined' ? navigator.language || navigator.userLanguage : 'en'
    return nav && nav.toLowerCase().startsWith('zh') ? 'zh' : 'en'
  }, [])
  const [lang, setLangState] = useState(initial)
  const setLang = useCallback((l) => {
    setLangState(l)
    if (typeof window !== 'undefined') window.localStorage.setItem('lang', l)
  }, [])
  const t = useCallback((k) => {
    const d = dict[lang] || dict.en
    return d[k] || k
  }, [lang])
  useEffect(() => {}, [lang])
  return (
    <LanguageContext.Provider value={{ lang, setLang, t }}>
      {children}
    </LanguageContext.Provider>
  )
}

export function useLanguage() {
  return useContext(LanguageContext)
}
